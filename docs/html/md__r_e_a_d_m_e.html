<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QMLParser: QML Parser</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QMLParser<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A recursive descent parser for the language of Quantified Modal Logic.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">QML Parser</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a></p>
<p>A recursive descent parser for the language of Quantified Modal Logic.</p>
<p>This library has been developed as part of my work as a Researcher at <a href="https://iif.conicet.gov.ar/?lan=en">IIF/SADAF/CONICET</a> and as member of the <a href="https://talk-group.org/">Talk Group</a>.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Description</h1>
<p>The QMLParser library parses the language of Quantified Modal Logic under the following specification of <b>vocabulary</b> and <b>syntax</b>.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
1. Vocabulary</h2>
<p>The vocabulary of Quantified Modal Logic is composed of:</p>
<ul>
<li><b>Logical Operators</b>: ¬, ↔, →, ∧, ∨</li>
<li><b>Modal operators</b>: □, ⋄</li>
<li><b>Quantifiers</b>: ∀, ∃</li>
<li><b>Variables</b>: x, y, z, x1, x2..., y_1, y_2...</li>
<li><b>Predicates</b>: Walk, Run, etc.</li>
<li><b>Individual constants</b>: John, Mary, etc.</li>
<li><b>Identity</b>: =</li>
</ul>
<p>For convenience, it also includes the <b>negated existential quantifier</b> (∄) and the <b>inequality operator</b> (≠).</p>
<h3><a class="anchor" id="autotoc_md3"></a>
1.1. Non-logical symbols</h3>
<p>The non-logical symbols are treated as identifiers that may include any of these symbols:</p>
<ul>
<li>a dot (.)</li>
<li>an underscore (_)</li>
<li>any alphanumeric character</li>
</ul>
<p>No constraints are imposed on how these may be combined. That is., "John" and "Mary_1" are valid identifiers, but also are "\_.\_" and "..J.h\_\_on". For your convenience, try to be sensible. The parser, however, won't care.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
1.2. Variables</h3>
<p>Variables are required to have one of the following formats:</p>
<ul>
<li>a single x, y, z character</li>
<li>a single x, y, z character followed by one or more digits</li>
<li>a single x, y, z character followed by an underscore, followed by one or more digits</li>
</ul>
<p>Nothing else will be considered a variable.</p>
<p>As an illustration:</p>
<ul>
<li>the following will be recognized as variables: x, y_1, z2</li>
<li>the following will be treated as non-variable identifiers: x_, y__2, zz2</li>
</ul>
<h3><a class="anchor" id="autotoc_md5"></a>
1.3. Logical Symbols</h3>
<p>The lexer recognizes the following logical symbols:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">SYMBOL   </th><th class="markdownTableHeadNone">NAME   </th><th class="markdownTableHeadNone">CODE POINT   </th><th class="markdownTableHeadNone">ENCODED BYTES    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">IDENTITY   </td><td class="markdownTableBodyNone">U+003D   </td><td class="markdownTableBodyNone">0x3D    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">¬   </td><td class="markdownTableBodyNone">NEGATION   </td><td class="markdownTableBodyNone">U+00AC   </td><td class="markdownTableBodyNone">0xC2 0xAC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">→   </td><td class="markdownTableBodyNone">IMPLICATION   </td><td class="markdownTableBodyNone">U+2192   </td><td class="markdownTableBodyNone">0xE2 0x86 0x92    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">↔   </td><td class="markdownTableBodyNone">EQUIVALENCE   </td><td class="markdownTableBodyNone">U+2194   </td><td class="markdownTableBodyNone">0xE2 0x86 0x94    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">∀   </td><td class="markdownTableBodyNone">FORALL   </td><td class="markdownTableBodyNone">U+2200   </td><td class="markdownTableBodyNone">0xE2 0x88 0x80    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">∃   </td><td class="markdownTableBodyNone">EXISTS   </td><td class="markdownTableBodyNone">U+2203   </td><td class="markdownTableBodyNone">0xE2 0x88 0x83    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">∄   </td><td class="markdownTableBodyNone">NOT_EXISTS   </td><td class="markdownTableBodyNone">U+2204   </td><td class="markdownTableBodyNone">0xE2 0x88 0x84    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">∧   </td><td class="markdownTableBodyNone">CONJUNCTION   </td><td class="markdownTableBodyNone">U+2227   </td><td class="markdownTableBodyNone">0xE2 0x88 0xA7    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">∨   </td><td class="markdownTableBodyNone">DISJUNCTION   </td><td class="markdownTableBodyNone">U+2228   </td><td class="markdownTableBodyNone">0xE2 0x88 0xA8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">≠   </td><td class="markdownTableBodyNone">INEQUALITY   </td><td class="markdownTableBodyNone">U+2260   </td><td class="markdownTableBodyNone">0xE2 0x89 0xA0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">⋄   </td><td class="markdownTableBodyNone">DIAMOND   </td><td class="markdownTableBodyNone">U+22C4   </td><td class="markdownTableBodyNone">0xE2 0x8B 0x84    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">□   </td><td class="markdownTableBodyNone">SQUARE   </td><td class="markdownTableBodyNone">U+25A1   </td><td class="markdownTableBodyNone">0xE2 0x96 0xA1   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md6"></a>
2. Syntax</h2>
<p>The QML Parser implements the following EBNF grammar for QML:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">NON-TERMINAL   </th><th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">DEFINITION    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">equivalence   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">implication, {"↔", implication}    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">implication   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">con_dis, {"→", con_dis}    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">con_dis   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">unary, {"∧", unary}    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">|   </td><td class="markdownTableBodyNone">unary, {"∨", unary}    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unary   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">atomic    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">|   </td><td class="markdownTableBodyNone">"¬"|"□"|"⋄", unary    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">|   </td><td class="markdownTableBodyNone">"∀"|"∃"|"∄", variable, unary    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">|   </td><td class="markdownTableBodyNone">"(", equivalence, ")"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">|   </td><td class="markdownTableBodyNone">"[", equivalence, "]"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">atomic   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">predication    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">|   </td><td class="markdownTableBodyNone">identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">|   </td><td class="markdownTableBodyNone">inequality    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">predication   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">identifier, "(", term, {", ", term}, ")"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">identity   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">term, "=", term    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">inequality   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">term, "≠", term    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">term   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">identifier|variable   </td></tr>
</table>
<p>A few notes on the parser implementation of this grammar:</p>
<ul>
<li>the order of operator precedence is implicitly defined as: ↔ &gt; → &gt; {∧, ∨} &gt; {¬, □, ⋄, ∀, ∃, ∄}</li>
<li>when two operators have the same precedence, precedence is left-associative</li>
<li>order of precedence can be altered by the use of parentheses or backets in the expected way</li>
</ul>
<p>Also:</p>
<ul>
<li>identifiers and variables are characterized in the <b>Vocabulary</b> section above</li>
<li>the start rule for the parser is a <code>sentence</code> non-terminal, which is an alias for one of the rules above (by default, equivalence) &mdash; see <b>Usage</b> for how to set <code>sentence</code> as an alias for a different EBNF rule.</li>
</ul>
<h1><a class="anchor" id="autotoc_md7"></a>
Directory structure</h1>
<div class="fragment"><div class="line">/</div>
<div class="line">├── qml-lexer/             # Lexer functionality</div>
<div class="line">│   ├── include/           # Public headers</div>
<div class="line">│   └── src/               # Implementation files</div>
<div class="line">├── qml-parser/            # Parsing functionality</div>
<div class="line">│   ├── include/           # Public headers</div>
<div class="line">│   └── src/               # Implementation files</div>
<div class="line">└── QMLParser/</div>
<div class="line">    └── include/           # convenience header</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Build and install</h1>
<p>Clone the repository: </p><div class="fragment"><div class="line">git clone git@github.com:r-caso/QMLParser.git</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
Prerequisites</h2>
<ul>
<li>C++23 compatible compiler</li>
<li>CMake 3.22 or newer</li>
<li><a href="https://github.com/r-caso/QMLExpression">QMLExpression</a> library</li>
</ul>
<p>Take notice that the QMLParser library requires the <a href="https://github.com/r-caso/QMLExpression">QMLExpression</a> library. To install it, follow the instructions in the corresponding <a href="https://github.com/r-caso/QMLParser/blob/main/README.md">README</a> (notice that it need not be installed as a system library).</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Building</h2>
<p>Once you have a working installation of QMLExpression, to build the QMLParser library, navigate to the QMLParser root folder, and do the following:</p>
<div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake ..</div>
<div class="line">cmake --build .</div>
</div><!-- fragment --><p>If QMLExpression is not installed as a system library, you have to tell CMake. Instead of <code>cmake ..</code>, do: </p><div class="fragment"><div class="line">cmake .. -DCMAKE_PREFIX_PATH=/path/to/QMLExpression</div>
</div><!-- fragment --><p> Or you can add the following key-value pair in the <code>cacheVariables</code> array of your <code>CMakePresets.json</code>: </p><div class="fragment"><div class="line">&quot;CMAKE_PREFIX_PATH&quot; : &quot;/path/to/QMLExpression&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Installing</h2>
<p>To install QMLParser as a system library: </p><div class="fragment"><div class="line">cmake --install .</div>
</div><!-- fragment --><p> To install QMLParser to a custom loction (non-system library): </p><div class="fragment"><div class="line">cmake --install . --prefix /path/to/QMLExpression</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md12"></a>
Usage</h1>
<h2><a class="anchor" id="autotoc_md13"></a>
Including in your project</h2>
<p>Once installed, you can use QMLParser in your CMake project in multiple ways:</p>
<div class="fragment"><div class="line">find_package(QMLParser REQUIRED)</div>
<div class="line"> </div>
<div class="line"># Link to the entire QMLParser interface</div>
<div class="line">target_link_libraries(your_target PRIVATE QMLParser::QMLParser)</div>
<div class="line"> </div>
<div class="line"># OR link to specific components</div>
<div class="line">target_link_libraries(your_target PRIVATE QMLParser::qml-lexer QMLParser::qml-parser)</div>
<div class="line"> </div>
<div class="line"># OR link to just one component</div>
<div class="line">target_link_libraries(your_target PRIVATE QMLParser::qml-lexer)</div>
</div><!-- fragment --><p>If you have installed QMLParser as a non-system library, you should tell CMake where to find it. Use the <code>-DCMAKE_PREFIX_PATH=/path/to/QMLParser</code> flag for the command line interface, or the <code>"CMAKE_PREFIX_PATH" : "/path/to/QMLParser"</code> under <code>cacheVariables</code> in <code>CMakePresets.json</code>.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Lexing and parsing QML formulas</h2>
<p>The QMLParser library has several header files, but you will be mainly interested in the following two main components:</p>
<ul>
<li>a <em>lexer</em> that takes a <code>std::string</code> as input and return a <code>std::vector&lt;Token&gt;</code> as output, and</li>
<li>a <em>parser</em> that takes a <code>std::vector&lt;Token&gt;</code> as input, and returns a <code>Expression</code> object as output.</li>
</ul>
<p>The <code>Token</code> class is declared <a href="QMLParser/include/token.hpp">here</a>. The <code>Expression</code> objects are provided, as an external dependency, by the <a href="https://github.com/r-caso/QMLExpression">QMLExpression library</a> (imported as a submodule of the project).</p>
<p>The lexer and parser components can be accessed with the following include directives: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;QMLParser/lexer.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;QMLParser/parser.hpp&gt;</span></div>
</div><!-- fragment --><p>The QMLParser library also includes a convenience header that pulls in every function and class: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;QMLParser/QMLParser.hpp&gt;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
1. Invoking the parser</h2>
<p>A manual run of the lexer-parser workflow goes as follows: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>QMLExpr = iif_sadaf::talk::QMLExpression;</div>
<div class="line"><span class="keyword">namespace </span>QMLParser = <a class="code hl_namespace" href="namespaceiif__sadaf_1_1talk_1_1_q_m_l_parser.html">iif_sadaf::talk::QMLParser</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::string formula = <span class="stringliteral">&quot;∃x Walk(x)&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> std::vector&lt;QMLParser::Token&gt; tokens = QMLParser::lex(formula);</div>
<div class="line">std::expected&lt;QMLExpr::Expression, std::string&gt; result = QMLParser::Parser(tokens).parse();</div>
<div class="ttc" id="anamespaceiif__sadaf_1_1talk_1_1_q_m_l_parser_html"><div class="ttname"><a href="namespaceiif__sadaf_1_1talk_1_1_q_m_l_parser.html">iif_sadaf::talk::QMLParser</a></div><div class="ttdef"><b>Definition</b> lexer.hpp:14</div></div>
</div><!-- fragment --><p> Alternatively, you can use the convenience function <code>parse()</code>: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::string formula = <span class="stringliteral">&quot;∃x Walk(x)&quot;</span>;</div>
<div class="line">std::expected&lt;QMLExpr::Expression, std::string&gt; result = QMLParser::parse(formula);</div>
</div><!-- fragment --><p> You can test whether parsing was successful by calling the <code>has_value()</code> method of <code>std::expected</code>: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (result.has_value()) {</div>
<div class="line">    <span class="comment">// code to run upon success</span></div>
<div class="line">    <span class="comment">// use result.value() to access the `Expression` object</span></div>
<div class="line">    <span class="comment">// into which the formula was parsed</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// code to run upon failure</span></div>
<div class="line">    <span class="comment">// use result.error() to access the error message</span></div>
<div class="line">    <span class="comment">// generated by the parser</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
2. Parser configuration</h2>
<p>The <code>Parser</code> class is designed for flexibility, allowing <b>runtime selection</b> of both:</p>
<ol type="1">
<li><b>The entry point</b> – the starting function for parsing (e.g., <code>equivalence</code>, <code>implication</code>, etc.).</li>
<li><b>The mapping function</b> – which maps <code>TokenType</code> to logical operators, enabling different logical systems.</li>
</ol>
<p>This makes the parser highly adaptable to different logic systems without modifying its core.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
2.1. Selecting the entry point</h3>
<p>By default, parsing starts at equivalence, but you can specify any supported entry point, either by manually calling the <code>QMLParser::parse()</code> method with an appropriate argument:</p>
<div class="fragment"><div class="line">std::expected&lt;QMLExpr::Expression, std::string&gt; result = QMLParser::Parser(tokens).parse(&amp;QMLParser::Parser::implication);</div>
</div><!-- fragment --><p> or by calling the <code>parse()</code> convenience function with that same argument: </p><div class="fragment"><div class="line">std::expected&lt;QMLExpr::Expression, std::string&gt; result = QMLParser::parse(formula, &amp;QMLParser::Parser::implication);</div>
</div><!-- fragment --><p> The list of rules that may serve as entry point for the parser is provided in <a href="parser.hpp">parser.hpp</a>.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
2.2. Customizing the Mapping Function</h3>
<p>The mapping function determines how <code>TokenType</code> values map to logical operators (<code>QML::Operator</code>). This allows different logical systems (e.g., modal logic, deontic logic) to reuse the same parser. For example:</p>
<ul>
<li>if you use a map to deontic modal logic, the necessity operator □ will be mapped to a deontic necessity modal operator (<code>QML::Operator::DEONTIC_NECESSITY</code>), and the possibility operator ⋄ will be mapped to a deontic possibility operator (<code>QML::Operator::DEONTIC_POSSIBILITY</code>);</li>
<li>if you use a map to epistemic modal logic, the necessity operator □ will be mapped to a deontic necessity modal operator (<code>QML::Operator::EPISTEMIC_NECESSITY</code>), and the possibility operator ⋄ will be mapped to a deontic possibility operator (<code>QML::Operator::EPISTEMIC_POSSIBILITY</code>).</li>
</ul>
<p>These different mappings will result in <code>Expression</code> objects with modal operators of different flavors.</p>
<p>By default, the QMLParser maps □ to <code>QML::Operator::NECESSITY</code>, and ⋄ to <code>QML::Operator::POSSIBILITY</code>, but this can be changed by explicitly providing a different mapping function: </p><div class="fragment"><div class="line">std::expected&lt;QMLExpr::Expression, std::string&gt; result = QMLParser::Parser(tokens, QMLParser::mapToDeonticOperator).parse();</div>
</div><!-- fragment --><p> or with the convenience <code>parse()</code> function: </p><div class="fragment"><div class="line">std::expected&lt;QMLExpr::Expression, std::string&gt; result = QMLParser::parse(formula, QMLParser::mapToDeonticOperator);</div>
</div><!-- fragment --><p> Obviously, you can customize in both ways at the same time: </p><div class="fragment"><div class="line">std::expected&lt;QMLExpr::Expression, std::string&gt; result = QMLParser::Parser(tokens, QMLParser::mapToDeonticOperator).parse(&amp;QMLParser::Parser::implication);</div>
</div><!-- fragment --><div class="fragment"><div class="line">std::expected&lt;QMLExpr::Expression, std::string&gt; result = QMLParser::parse(formula, &amp;QMLParser::Parser::implication, QMLParser::mapToEpistemicOperator);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md19"></a>
Contributing</h1>
<p>Contributions are more than welcome. If you want to contribute, please do the following:</p>
<ol type="1">
<li>Fork the repository.</li>
<li>Create a new branch: <code>git checkout -b feature-name</code>.</li>
<li>Make your changes.</li>
<li>Push your branch: <code>git push origin feature-name</code>.</li>
<li>Create a pull request.</li>
</ol>
<h1><a class="anchor" id="autotoc_md20"></a>
License</h1>
<p>This project is licensed under the [BSD-3-Clause](LICENSE). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
